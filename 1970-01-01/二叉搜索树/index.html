<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>二叉搜索树 | zhangzhengsmiling</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">二叉搜索树</h1><a id="logo" href="/.">zhangzhengsmiling</a><p class="description">stand on eminence and become farsighted</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">二叉搜索树</h1><div class="post-meta">1970-01-01<span> | </span><span class="category"><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 2.8k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 12</span><span class="post-meta-item-text"> 分钟</span></span></span></div><a class="ds-thread-count" href="/1970-01-01/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/#SOHUCS"><span id="changyan_count_unit" style="font-size: 15px; color: #6E7173;">0</span><span> 条评论</span></a><script src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js" async></script><div class="post-content"><h4 id="二叉搜索树（Binary-Search-Tree）"><a href="#二叉搜索树（Binary-Search-Tree）" class="headerlink" title="二叉搜索树（Binary Search Tree）"></a>二叉搜索树（Binary Search Tree）</h4><ul>
<li><p>二叉搜索树的定义：</p>
<blockquote>
<p>**<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9">二叉查找树</a>**，是指一棵空树或者具有下列性质的二叉树：</p>
<ol>
<li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li>
<li>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li>
<li>任意节点的左、右子树也分别为二叉查找树；</li>
</ol>
</blockquote>
</li>
</ul>
<p>首先，先来看一个二叉搜索树的例子，认识一下什么样的树是一棵二叉搜索树:</p>
<p><img src="/img/bst/image-20210816235506740.png" alt="image-20210816235506740"></p>
<p>对于二叉树中的每一棵子树，其左子树中的所有节点key值都小于根节点；其右子树中的所有节点key值均大于根节点</p>
<p><strong>注：为简化问题，暂时不考虑子树中key值相同的节点，即默认二叉树中key值是惟一的</strong></p>
<h4 id="二叉搜索树的中序遍历"><a href="#二叉搜索树的中序遍历" class="headerlink" title="二叉搜索树的中序遍历"></a>二叉搜索树的中序遍历</h4><p><img src="/img/bst/image-20210817093503961.png" alt="image-20210817093503961"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TTreeNode</span>&lt;<span class="title">DataType</span>&gt; </span>&#123;</span><br><span class="line">  key: <span class="built_in">number</span>;</span><br><span class="line">  value: DataType;</span><br><span class="line">  left: TTreeNode&lt;DataType&gt; | <span class="literal">null</span>;</span><br><span class="line">  right: TTreeNode&lt;DataType&gt; | <span class="literal">null</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">key: <span class="built_in">number</span>, value: DataType</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.key = key;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="built_in">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 生成测试数据</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子节点索引计算</span></span><br><span class="line"><span class="keyword">const</span> left = <span class="function"><span class="params">idx</span> =&gt;</span> idx * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> right = <span class="function"><span class="params">idx</span> =&gt;</span> idx * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以层级遍历构造二叉树</span></span><br><span class="line"><span class="keyword">const</span> buildTree = <span class="function">(<span class="params">nums: (<span class="built_in">number</span> | <span class="literal">null</span>)[]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 控制下标从1开始</span></span><br><span class="line">  <span class="keyword">const</span> list = [<span class="literal">null</span>, ...nums].map(</span><br><span class="line">    item =&gt; item === <span class="literal">null</span> ? <span class="literal">null</span> : (</span><br><span class="line">      <span class="keyword">new</span> TTreeNode&lt;<span class="built_in">string</span>&gt;(item, <span class="string">`data-<span class="subst">$&#123;item&#125;</span>`</span>)</span><br><span class="line">    )</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">let</span> root: TTreeNode&lt;<span class="built_in">string</span>&gt; | <span class="literal">null</span> = list[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="built_in">Math</span>.floor(list.length / <span class="number">2</span>); i++) &#123;</span><br><span class="line">    list[i].left = list[left(i)];</span><br><span class="line">    list[i].right = list[right(i)];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tree = buildTree([</span><br><span class="line">  <span class="number">6</span>,</span><br><span class="line">  <span class="number">4</span>, <span class="number">9</span>,</span><br><span class="line">  <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">11</span>,</span><br><span class="line">  <span class="number">1</span>, <span class="number">3</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">7</span>, <span class="literal">null</span>, <span class="number">10</span>, <span class="literal">null</span></span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">in_order(tree);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>二叉树的中序遍历</p>
<p>(递归版本)</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> <span class="function"><span class="title">in_order</span>(<span class="params">root</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root.left)</span><br><span class="line">        in_order(root.left);</span><br><span class="line">    </span><br><span class="line">    print(root.key);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (root.right)</span><br><span class="line">        in_order(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(迭代版本：借用栈实现)</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">in_order</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">let</span> stack = [];</span><br><span class="line">  <span class="keyword">let</span> ptr = root;</span><br><span class="line">  <span class="keyword">while</span>(stack.length &gt; <span class="number">0</span> || ptr !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span>(ptr) &#123;</span><br><span class="line">      stack.push(ptr);</span><br><span class="line">      ptr = ptr.left</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> target = stack.pop();</span><br><span class="line">    <span class="built_in">console</span>.log(target.key);</span><br><span class="line">    ptr = target.right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86">二叉树的遍历，可参考维基百科</a></p>
<p>DFS</p>
<ul>
<li>Pre-order</li>
<li>In-order</li>
<li>Post-order</li>
</ul>
<p>BFS</p>
<h4 id="二叉搜索树的操作"><a href="#二叉搜索树的操作" class="headerlink" title="二叉搜索树的操作"></a>二叉搜索树的操作</h4><ul>
<li>二叉搜索树节点类型声明</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">DataType</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> key: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">public</span> value: DataType;</span><br><span class="line">  <span class="keyword">public</span> left: TreeNode&lt;DataType&gt; | <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">public</span> right: TreeNode&lt;DataType&gt; | <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">public</span> parent: TreeNode&lt;DataType&gt; | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">key: <span class="built_in">number</span>, value: DataType</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.key = key;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="built_in">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.parent = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">reset</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.parent = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">isLeftChild</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.parent === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.parent.left === <span class="built_in">this</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">isRightChild</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.parent === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> !<span class="built_in">this</span>.isLeftChild();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">isRoot</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.parent === <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">isLeafNode</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.left === <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.right === <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h5><ul>
<li>在二叉搜索树中根据给定关键字key查找节点：<ol>
<li>从二叉搜索树的根节点开始进行比较</li>
<li>若节点的key值与给定的key值相等，查询成功，搜索结束</li>
<li>若给定的key值大于节点的key，则对右子树进行搜索；反之，对左子树进行搜索</li>
<li>当节点为null时，仍未匹配key值，则查询失败，搜索结束</li>
</ol>
</li>
</ul>
<p><img src="/img/bst/7dfd6cb6a3134b2999a02d513dea518c_th.png" alt="7dfd6cb6a3134b2999a02d513dea518c_th"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span>&lt;<span class="title">DataType</span>&gt; </span>&#123;</span><br><span class="line">  root: TreeNode&lt;DataType&gt; = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  find(key: <span class="built_in">number</span>): TreeNode&lt;DataType&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> ptr = <span class="built_in">this</span>.root;</span><br><span class="line">    <span class="keyword">while</span>(ptr !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (key === ptr.key) <span class="keyword">return</span> ptr;</span><br><span class="line">      <span class="keyword">if</span> (key &lt; ptr.key) ptr = ptr.left;</span><br><span class="line">      <span class="keyword">else</span> ptr = ptr.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`key: <span class="subst">$&#123;key&#125;</span> is not found...`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 搜索</span></span><br><span class="line">  search(key: <span class="built_in">number</span>): DataType &#123;</span><br><span class="line">    <span class="keyword">const</span> target = <span class="built_in">this</span>.find(key);</span><br><span class="line">    <span class="keyword">return</span> target.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h5><ul>
<li><p>给定一个key值和value构成的节点，将节点插入二叉搜索树中，使得插入完成后的树依然是一棵二叉搜索树</p>
<p>与搜索的逻辑类似，只不过需要新增一个父节点指针</p>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span>&lt;<span class="title">DataType</span>&gt; </span>&#123;</span><br><span class="line">  root: TreeNode&lt;DataType&gt; = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向二叉搜索树中插入节点  </span></span><br><span class="line">  <span class="function"><span class="title">insert</span>(<span class="params">key: <span class="built_in">number</span>, value: DataType</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> node: TreeNode&lt;DataType&gt; = <span class="keyword">new</span> TreeNode&lt;DataType&gt;(key, value);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">this</span>.root = node;</span><br><span class="line">    <span class="keyword">let</span> ptr = <span class="built_in">this</span>.root;</span><br><span class="line">    <span class="comment">// ptr的父指针</span></span><br><span class="line">    <span class="keyword">let</span> _p: TreeNode&lt;DataType&gt; | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(ptr !== <span class="literal">null</span>) &#123;</span><br><span class="line">      _p = ptr;</span><br><span class="line">      <span class="keyword">if</span> (key &lt; ptr.key) ptr = ptr.left;</span><br><span class="line">      <span class="keyword">else</span> ptr = ptr.right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    node.parent = _p;</span><br><span class="line">    <span class="keyword">if</span>(key &lt; _p.key) _p.left = node;</span><br><span class="line">    <span class="keyword">else</span> _p.right = node;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="节点的前驱和后继"><a href="#节点的前驱和后继" class="headerlink" title="节点的前驱和后继"></a>节点的前驱和后继</h5><p>在聊二叉搜索树的删除之前，需要了解一个比较重要的概念，二叉搜索树节点的<strong>前驱节点</strong>和<strong>后继节点</strong></p>
<ul>
<li><p>后继节点</p>
<ol>
<li><p>如果节点存在右子树，则后继节点是右子树中的key值最小的节点</p>
</li>
<li><p>如果节点不存在右子树，则要向上层节点回溯，找到一个父级节点，使得node节点在父级节点的左子树中；</p>
<p>若未找到满足条件的父级节点，则说明node节点是最右侧的节点（搜索树最大节点），则不存在后继节点</p>
</li>
</ol>
<p><img src="/img/bst/12906546-90623e8e484cffda.png" alt="12906546-90623e8e484cffda"></p>
</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span>&lt;<span class="title">DataType</span>&gt; </span>&#123;</span><br><span class="line">  root: TreeNode&lt;DataType&gt; = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 查找某一棵二叉搜索树的最小值</span></span><br><span class="line">  <span class="comment">// 子树的最左侧节点即为key值最小节点</span></span><br><span class="line">  _min(node: TreeNode&lt;DataType&gt;): TreeNode&lt;DataType&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> ptr = node;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(ptr !== <span class="literal">null</span>) &#123;</span><br><span class="line">      p = ptr;</span><br><span class="line">      ptr = ptr.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算节点的后继节点</span></span><br><span class="line">  _next(node: TreeNode&lt;DataType&gt;): TreeNode&lt;DataType&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (node === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (node.right !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 节点node存在右子树</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>._min(node.right);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 节点node不存在右子树</span></span><br><span class="line">      <span class="keyword">let</span> ptr = node;</span><br><span class="line">      <span class="keyword">while</span>(ptr.parent !== <span class="literal">null</span> &amp;&amp; ptr !== ptr.parent.left) &#123;</span><br><span class="line">        ptr = ptr.parent;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ptr.parent;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>前驱节点</p>
<ol>
<li><p>如果节点存在左子树，则后继节点是左子树中的key值最大的节点</p>
</li>
<li><p>如果节点不存在左子树，则要向上层节点回溯，找到一个父级节点，使得node节点在父级节点节点的右子树中；</p>
<p>若未找到满足条件的父级节点，则说明node节点是最左侧的节点（搜索树最小节点），则不存在后继节点    </p>
</li>
</ol>
<p><img src="/img/bst/12906546-bfaf6ef498e495e4.png" alt="12906546-bfaf6ef498e495e4"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span>&lt;<span class="title">DataType</span>&gt; </span>&#123;</span><br><span class="line">  root: TreeNode&lt;DataType&gt; = <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 计算节点的前驱节点</span></span><br><span class="line">  _prev(node: TreeNode&lt;DataType&gt;): TreeNode&lt;DataType&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (node === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (node.left !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// node存在左子树</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>._max(node.left);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// node不存在左子树</span></span><br><span class="line">      <span class="keyword">let</span> ptr = node;</span><br><span class="line">      <span class="keyword">while</span>(ptr.parent !== <span class="literal">null</span> &amp;&amp; ptr.parent.left === ptr) &#123;</span><br><span class="line">        ptr = ptr.parent;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ptr.parent;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 查找某一棵二叉搜索树的key值最大的节点</span></span><br><span class="line">	<span class="comment">// 不断搜索右子树，直到最右侧节点，极为key值最大节点  </span></span><br><span class="line">  _max(node: TreeNode&lt;DataType&gt;): TreeNode&lt;DataType&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> ptr = node;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(ptr !== <span class="literal">null</span>) &#123;</span><br><span class="line">      p = ptr;</span><br><span class="line">      ptr = ptr.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><ul>
<li><p>二叉树节点的删除</p>
<p>给定一个key值，从二叉搜索树中删除对应节点，需要保证删除后的二叉树依然是一棵二叉搜索树</p>
<p>节点删除比较复杂，需要分为以下三种情况：</p>
<p><strong><em>CASE 1</em>：</strong></p>
<p>待删除节点Z没有孩子节点，即Z为叶子节点，直接删除节点，重置parent指针</p>
<p><img src="/img/bst/20180320102503303.png" alt="image"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (target.isLeafNode()) &#123;</span><br><span class="line">  <span class="comment">// 目标节点没有子节点的情况</span></span><br><span class="line">  <span class="keyword">if</span> (target.isRoot()) &#123;</span><br><span class="line">    <span class="built_in">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> flag = target.isLeftChild() ? <span class="string">&#x27;left&#x27;</span> : <span class="string">&#x27;right&#x27;</span>;</span><br><span class="line">    target.parent[flag] = <span class="literal">null</span>;</span><br><span class="line">    target.parent = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>CASE 2</em></strong>：</p>
<p>待删除节点Z有且仅有一个子节点，则将Z节点删除，用Z节点的子节点取代原先的Z节点，更新parent指针</p>
<p><img src="/img/bst/20180320102654636.png" alt="image"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CASE 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有且仅有左子节点或者右子节点</span></span><br><span class="line"><span class="keyword">const</span> targetFlag = target.left === <span class="literal">null</span> ? <span class="string">&#x27;right&#x27;</span> : <span class="string">&#x27;left&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> targetParent = target.parent;</span><br><span class="line"><span class="keyword">if</span> (target.isRoot()) &#123;</span><br><span class="line">  <span class="comment">// 根节点</span></span><br><span class="line">  <span class="built_in">this</span>.root = target[targetFlag];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> parentFlag = target.isLeftChild() ? <span class="string">&#x27;left&#x27;</span> : <span class="string">&#x27;right&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> parent = target.parent;</span><br><span class="line">  parent[parentFlag] = target[targetFlag];</span><br><span class="line">&#125;</span><br><span class="line">target[targetFlag].parent = targetParent;</span><br><span class="line">target.reset();</span><br></pre></td></tr></table></figure>

<p><strong><em>CASE 3:</em></strong></p>
<p>待删除节点Z有两个子节点，此时删除Z节点后有两种策略：</p>
<ul>
<li>策略一：从左子树中找出key值最大的节点（即节点Z的前驱节点），取代删除的节点Z</li>
<li>策略二：从右子树中找出key值最小的节点（即节点Z的后继节点），取代删除的节点Z</li>
</ul>
<p>（主要目标是从Z节点的所有子节点中找出一个节点，满足这个节点的key比所有左子树中的key要大，比右子树中的key要小。）</p>
<p><img src="/img/bst/20180320102800274.png" alt="image"></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(target.left !== <span class="literal">null</span> &amp;&amp; target.right !== <span class="literal">null</span>) &#123;</span><br><span class="line">	<span class="comment">// CASE 3  </span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> next = <span class="built_in">this</span>._next(target);</span><br><span class="line">  <span class="comment">// 释放next节点的父节点指针</span></span><br><span class="line">  <span class="keyword">const</span> flag = next.isLeftChild() ? <span class="string">&#x27;left&#x27;</span> : <span class="string">&#x27;right&#x27;</span>;</span><br><span class="line">  next.parent[flag] = next.right;</span><br><span class="line">  <span class="keyword">if</span> (target.isRoot()) &#123;</span><br><span class="line">    <span class="built_in">this</span>.root = next;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> parentFlag = target.parent.left === target ? <span class="string">&#x27;left&#x27;</span> : <span class="string">&#x27;right&#x27;</span>;</span><br><span class="line">    target.parent[parentFlag] = next;</span><br><span class="line">  &#125;</span><br><span class="line">  next.left = target.left;</span><br><span class="line">  next.right = target.right;</span><br><span class="line">  next.parent = target.parent;</span><br><span class="line">  target.left &amp;&amp; (target.left.parent = next);</span><br><span class="line">  target.right &amp;&amp; (target.right.parent = next);</span><br><span class="line">  target.reset();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span>(key: <span class="built_in">number</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> target = <span class="built_in">this</span>.find(key);</span><br><span class="line">  <span class="keyword">if</span> (target === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (target.isLeafNode()) &#123;</span><br><span class="line">    <span class="comment">// CASE 1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 目标节点没有子节点的情况</span></span><br><span class="line">    <span class="keyword">if</span> (target.isRoot()) &#123;</span><br><span class="line">      <span class="built_in">this</span>.root = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> flag = target.isLeftChild() ? <span class="string">&#x27;left&#x27;</span> : <span class="string">&#x27;right&#x27;</span>;</span><br><span class="line">      target.parent[flag] = <span class="literal">null</span>;</span><br><span class="line">      target.parent = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(target.left !== <span class="literal">null</span> &amp;&amp; target.right !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// CASE 3</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> next = <span class="built_in">this</span>._next(target);</span><br><span class="line">    <span class="keyword">if</span> (next.isLeftChild()) &#123;</span><br><span class="line">      next.parent.left = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      next.parent.right = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (target.isRoot()) &#123;</span><br><span class="line">      <span class="built_in">this</span>.root = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> parentFlag = target.parent.left === target ? <span class="string">&#x27;left&#x27;</span> : <span class="string">&#x27;right&#x27;</span>;</span><br><span class="line">      target.parent[parentFlag] = next;</span><br><span class="line">    &#125;</span><br><span class="line">    next.left = target.left;</span><br><span class="line">    next.right = target.right;</span><br><span class="line">    next.parent = target.parent;</span><br><span class="line">    target.left &amp;&amp; (target.left.parent = next);</span><br><span class="line">    target.right &amp;&amp; (target.right.parent = next);</span><br><span class="line">    target.reset();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// CASE 2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 有且仅有左子节点或者右子节点</span></span><br><span class="line">    <span class="keyword">const</span> targetFlag = target.left === <span class="literal">null</span> ? <span class="string">&#x27;right&#x27;</span> : <span class="string">&#x27;left&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> targetParent = target.parent;</span><br><span class="line">    <span class="keyword">if</span> (target.isRoot()) &#123;</span><br><span class="line">      <span class="comment">// 根节点</span></span><br><span class="line">      <span class="built_in">this</span>.root = target[targetFlag];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> parentFlag = target.isLeftChild() ? <span class="string">&#x27;left&#x27;</span> : <span class="string">&#x27;right&#x27;</span>;</span><br><span class="line">      <span class="keyword">const</span> parent = target.parent;</span><br><span class="line">      parent[parentFlag] = target[targetFlag];</span><br><span class="line">    &#125;</span><br><span class="line">    target[targetFlag].parent = targetParent;</span><br><span class="line">    target.reset();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h5 id="二叉搜索树问题及优化"><a href="#二叉搜索树问题及优化" class="headerlink" title="二叉搜索树问题及优化"></a>二叉搜索树问题及优化</h5><p>二叉搜索树的算法复杂度</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>搜索</td>
<td>O（h）</td>
</tr>
<tr>
<td>插入</td>
<td>O（h）</td>
</tr>
<tr>
<td>删除</td>
<td>O（h）</td>
</tr>
</tbody></table>
<p>上述描述的复杂度中h二叉搜索树的高度，（ log n &lt; h &lt; n） 二叉搜索树的弊端在于其没有自平衡策略</p>
<p>最终二叉搜索树构建的过程中，受到输入数据的影响会导致二叉搜索的畸形</p>
<p><strong><em>WORST CASE</em></strong>:</p>
<p>考虑初始化数据为以下数据：</p>
<p>1, 2, 3 ,4 ,5 ,6 ,7 ,8, 9, 10</p>
<p><img src="/img/bst/image-20210818004346309.png" alt="image-20210818004346309"></p>
<p>在这种状况下，二叉搜索树与链表几乎没有区别，无论是搜索，插入还是删除，其复杂度均达到了O(n)</p>
<p><a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/BST.html">https://www.cs.usfca.edu/~galles/visualization/BST.html</a></p>
<h4 id="随机化算法"><a href="#随机化算法" class="headerlink" title="随机化算法"></a>随机化算法</h4><ol>
<li><p>随机化算法 + 二叉搜索树</p>
<p>给定一组数据[1, 2, 3, 4, 5, 6, 7, 8 ,9, 10],根据给定的数组构建一棵二叉搜索树</p>
<p><strong>朴素顺序算法</strong>，会按照给定数据顺序生成二叉搜索树</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bst = <span class="keyword">new</span> BinarySearchTree&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> n <span class="keyword">of</span> list) &#123;</span><br><span class="line">  bst.insert(n, <span class="string">`data-<span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>随机化算法</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line"><span class="keyword">const</span> bst = <span class="keyword">new</span> BinarySearchTree&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(list.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> random = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (list.length - <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">const</span> item = list.splice(random, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(item, random);</span><br><span class="line">  bst.insert(item[<span class="number">0</span>], <span class="string">`data-<span class="subst">$&#123;item&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/img/bst/image-20210819114411175.png" alt="image-20210819114411175"></p>
<p>随机化构建二叉搜索树，仅仅对于二叉树的初始化阶段是有效的，对于初始化完成后的插入与删除阶段是没有优化作用的</p>
<p>后续二叉树的插入和删除操作依然会导致二叉树的畸形</p>
</li>
<li><p>随机化算法 + 快速排序</p>
</li>
</ol>
</div><div class="tags"><a href="/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"><i class="fa fa-tag"></i>二叉搜索树</a><a href="/tags/%E9%9A%8F%E6%9C%BA%E5%8C%96%E7%AE%97%E6%B3%95/"><i class="fa fa-tag"></i>随机化算法</a></div><div class="post-nav"><a class="pre" href="/1970-01-01/%E4%BB%8E%E7%AE%80%E5%8D%95%E7%9A%84case%E8%AE%B2%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96--%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/">从简单的case讲算法优化--斐波那契数列</a><a class="next" href="/1970-01-01/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/">优先队列</a></div><div id="SOHUCS" sid="0"></div><script>(function(){var appid='cyviQPbMk';var conf='prod_05b30768a3e1678744671be122542ed1';var width=window.innerWidth||document.documentElement.clientWidth;if(width<960){window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id='+appid+'&conf='+conf+'"><\/script>')}else{var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})})}})()
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://zhangzhengsmiling.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/">服务器</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B5%8B%E8%AF%95/">测试</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/" style="font-size: 15px;">项目部署</a> <a href="/tags/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/" style="font-size: 15px;">单点登录</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 15px;">算法</a> <a href="/tags/%E8%AE%B0%E5%BF%86%E5%8C%96/" style="font-size: 15px;">记忆化</a> <a href="/tags/%E5%B0%BE%E9%80%92%E5%BD%92/" style="font-size: 15px;">尾递归</a> <a href="/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/" style="font-size: 15px;">斐波那契数列</a> <a href="/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" style="font-size: 15px;">单元测试</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/" style="font-size: 15px;">服务端渲染</a> <a href="/tags/server-side-render/" style="font-size: 15px;">server-side render</a> <a href="/tags/react/" style="font-size: 15px;">react</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/" style="font-size: 15px;">二叉搜索树</a> <a href="/tags/%E9%9A%8F%E6%9C%BA%E5%8C%96%E7%AE%97%E6%B3%95/" style="font-size: 15px;">随机化算法</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021-03-21/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/">服务端渲染</a></li><li class="post-list-item"><a class="post-list-link" href="/2021-03-21/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/">单点登录</a></li><li class="post-list-item"><a class="post-list-link" href="/2021-03-21/%E5%9B%BE%E8%A1%A8%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F/">图表数据格式</a></li><li class="post-list-item"><a class="post-list-link" href="/2021-03-21/nginx/">Nginx简介</a></li><li class="post-list-item"><a class="post-list-link" href="/2021-03-21/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">单元测试</a></li><li class="post-list-item"><a class="post-list-link" href="/2021-03-21/hello-world/">Hello World</a></li><li class="post-list-item"><a class="post-list-link" href="/1970-01-01/%E4%BB%8E%E7%AE%80%E5%8D%95%E7%9A%84case%E8%AE%B2%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96--%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/">从简单的case讲算法优化--斐波那契数列</a></li><li class="post-list-item"><a class="post-list-link" href="/1970-01-01/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/">二叉搜索树</a></li><li class="post-list-item"><a class="post-list-link" href="/1970-01-01/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/">优先队列</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/zhangzhengsmiling" title="github" target="_blank">github</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">zhangzhengsmiling.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>